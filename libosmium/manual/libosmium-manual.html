<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Osmium Library Manual</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="manual.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Osmium Library Manual</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#header-only-library"><span class="toc-section-number">1.1</span> Header-only Library</a></li>
<li><a href="#the-osmium-namespace"><span class="toc-section-number">1.2</span> The <code>osmium</code> Namespace</a></li>
<li><a href="#c11"><span class="toc-section-number">1.3</span> C++11</a></li>
<li><a href="#license"><span class="toc-section-number">1.4</span> License</a></li>
<li><a href="#old-versions-of-osmium"><span class="toc-section-number">1.5</span> Old Versions of Osmium</a></li>
</ul></li>
<li><a href="#compiling-programs-using-osmium"><span class="toc-section-number">2</span> Compiling Programs Using Osmium</a><ul>
<li><a href="#c11-1"><span class="toc-section-number">2.1</span> C++11</a></li>
<li><a href="#operating-systems"><span class="toc-section-number">2.2</span> Operating Systems</a></li>
<li><a href="#build-system"><span class="toc-section-number">2.3</span> Build System</a></li>
<li><a href="#large-file-support"><span class="toc-section-number">2.4</span> Large File Support</a></li>
<li><a href="#include-what-you-need"><span class="toc-section-number">2.5</span> Include What You Need</a></li>
<li><a href="#boost"><span class="toc-section-number">2.6</span> Boost</a></li>
<li><a href="#ogr-support"><span class="toc-section-number">2.7</span> OGR Support</a></li>
</ul></li>
<li><a href="#basic-types"><span class="toc-section-number">3</span> Basic Types</a><ul>
<li><a href="#ids"><span class="toc-section-number">3.1</span> IDs</a></li>
<li><a href="#other-primitive-types"><span class="toc-section-number">3.2</span> Other Primitive Types</a></li>
<li><a href="#locations"><span class="toc-section-number">3.3</span> Locations</a></li>
<li><a href="#segments"><span class="toc-section-number">3.4</span> Segments</a></li>
<li><a href="#undirected-segments"><span class="toc-section-number">3.5</span> Undirected Segments</a></li>
<li><a href="#boxes"><span class="toc-section-number">3.6</span> Boxes</a></li>
</ul></li>
<li><a href="#osm-entities"><span class="toc-section-number">4</span> OSM Entities</a><ul>
<li><a href="#osm-objects"><span class="toc-section-number">4.1</span> OSM Objects</a></li>
<li><a href="#nodes"><span class="toc-section-number">4.2</span> Nodes</a></li>
<li><a href="#ways"><span class="toc-section-number">4.3</span> Ways</a></li>
<li><a href="#relations"><span class="toc-section-number">4.4</span> Relations</a></li>
<li><a href="#areas"><span class="toc-section-number">4.5</span> Areas</a></li>
<li><a href="#changesets"><span class="toc-section-number">4.6</span> Changesets</a></li>
</ul></li>
<li><a href="#buffers"><span class="toc-section-number">5</span> Buffers</a><ul>
<li><a href="#creating-a-buffer"><span class="toc-section-number">5.1</span> Creating a Buffer</a></li>
<li><a href="#adding-items-to-the-buffer"><span class="toc-section-number">5.2</span> Adding Items to the Buffer</a></li>
<li><a href="#handling-a-full-buffer"><span class="toc-section-number">5.3</span> Handling a Full Buffer</a></li>
</ul></li>
<li><a href="#input-and-output"><span class="toc-section-number">6</span> Input and Output</a><ul>
<li><a href="#file-formats"><span class="toc-section-number">6.1</span> File Formats</a></li>
<li><a href="#compression"><span class="toc-section-number">6.2</span> Compression</a></li>
<li><a href="#headers"><span class="toc-section-number">6.3</span> Headers</a></li>
<li><a href="#output-formats"><span class="toc-section-number">6.4</span> Output Formats</a><ul>
<li><a href="#xml"><span class="toc-section-number">6.4.1</span> XML</a></li>
<li><a href="#pbf"><span class="toc-section-number">6.4.2</span> PBF</a></li>
<li><a href="#opl-object-per-line-format"><span class="toc-section-number">6.4.3</span> OPL (&quot;Object Per Line&quot;) Format</a></li>
</ul></li>
<li><a href="#reading-and-writing-osm-files-with-osmium"><span class="toc-section-number">6.5</span> Reading and Writing OSM Files with Osmium</a><ul>
<li><a href="#the-osmiumiofile-class"><span class="toc-section-number">6.5.1</span> The osmium::io::File class</a></li>
<li><a href="#reading-a-file"><span class="toc-section-number">6.5.2</span> Reading a File</a></li>
<li><a href="#the-header"><span class="toc-section-number">6.5.3</span> The Header</a></li>
</ul></li>
</ul></li>
<li><a href="#iterators"><span class="toc-section-number">7</span> Iterators</a><ul>
<li><a href="#accessing-data-in-buffers"><span class="toc-section-number">7.1</span> Accessing Data in Buffers</a></li>
<li><a href="#accessing-data-from-files"><span class="toc-section-number">7.2</span> Accessing Data from Files</a></li>
</ul></li>
<li><a href="#visitors-and-handlers"><span class="toc-section-number">8</span> Visitors and Handlers</a></li>
<li><a href="#indexes"><span class="toc-section-number">9</span> Indexes</a><ul>
<li><a href="#index-types"><span class="toc-section-number">9.1</span> Index Types</a><ul>
<li><a href="#map-index"><span class="toc-section-number">9.1.1</span> Map Index</a></li>
<li><a href="#storage-types"><span class="toc-section-number">9.1.2</span> Storage types</a></li>
</ul></li>
</ul></li>
<li><a href="#exceptions"><span class="toc-section-number">10</span> Exceptions</a><ul>
<li><a href="#list-of-osmium-exceptions"><span class="toc-section-number">10.1</span> List of Osmium Exceptions</a></li>
<li><a href="#standard-exceptions-thrown-by-osmium"><span class="toc-section-number">10.2</span> Standard Exceptions thrown by Osmium</a></li>
</ul></li>
</ul>
</div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p><em>Simple things should be simple and complex things should be possible.</em> - Alan Kay</p>
<p>The OpenStreetMap project is growing at an enormous rate. Working with the OSM data becomes increasingly difficult, because there is just so much of it and because it gets more complex all the time.</p>
<p>Osmium was developed as an answer to this challenge. After year of developing software to work with OSM data in many programming languages like Perl, Ruby, Java and even in XSLT, it became evident that something more was needed to efficiently work with these huge amounts of data. Processing speed was, of course, one big issue here, but the other one is available memory. Data processing tasks can be so much faster if their working set fits into memory, that it makes sense to think about this. Because Osmium is a C++ library it can make very efficient use of the main memory on your computer. Primitive objects such as integers and doubles, but also complex objects need only as much memory as is really necessary. There is not much management overhead needed in many cases, if the data structures are chosen carefully.</p>
<p>Osmium has been in continuous development since it was borne in October 2010. And it has changed considerably over time. While the basic premise, to write a low-level efficient OSM library, is still true, it has become more and more powerful and at the same time easier to use. Osmium has been in production use nearly from day one, some parts of it have been ripped from earlier production code. Osmium is not an academic exercise, but it is used and it has shown its power many times. And while C++ might not be the easiest programming language to learn and Osmium might not be the easiest library to use, we try to make it as simple as possible to work with it, as long as this doesn't compromise efficiency too much.</p>
<h2 id="header-only-library"><span class="header-section-number">1.1</span> Header-only Library</h2>
<p>Osmium is a header-only library, so there is nothing to compile to build it. Just include the header files you need.</p>
<h2 id="the-osmium-namespace"><span class="header-section-number">1.2</span> The <code>osmium</code> Namespace</h2>
<p>Everything in the Osmium library is in the <code>osmium</code> namespace or in sub-namespaces. You'll likely encounter the <code>osmium::io</code> namespace for everything related to <a href="#input-and-output">Input and Output</a> and the <code>osmium::geom</code> namespace for geometry-related functionality, but there are some more. Do not directly use anything in any sub-namespace called <code>detail</code>. Those classes and functions are for internal use only.</p>
<h2 id="c11"><span class="header-section-number">1.3</span> C++11</h2>
<p>The current version of Osmium makes extensive use of the new facilities provided by the C++11 standard. It will only work with current compilers and libraries.</p>
<h2 id="license"><span class="header-section-number">1.4</span> License</h2>
<p>The Osmium Library is available under the very liberal Boost Software License:</p>
<pre><code>Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the &quot;Software&quot;) to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.</code></pre>
<p>This manual is available under the Creative Commons <a href="http://creativecommons.org/licenses/by-sa/4.0/">Attribution-ShareAlike License version 4.0</a>.</p>
<h2 id="old-versions-of-osmium"><span class="header-section-number">1.5</span> Old Versions of Osmium</h2>
<p>If you are stuck with older compilers or need to develop using the older C++98 for some reason, you can have a look at the older Osmium version. But it is quite different from the current Osmium described in this manual.</p>
<p>The old Osmium is available from <a href="https://github.com/joto/osmium">GitHub</a>.</p>
<h1 id="compiling-programs-using-osmium"><span class="header-section-number">2</span> Compiling Programs Using Osmium</h1>
<p>Osmium is a header-only library, so it does not need to be compiled by itself. But of course you will have to compile programs using Osmium. This chapter gives you some hints on how to best do this.</p>
<h2 id="c11-1"><span class="header-section-number">2.1</span> C++11</h2>
<p>Osmium uses modern standard C++11 and should compile everywhere without warnings when you have a recent enough compiler and standard library. It works with GCC 4.8 and clang 3.2 or newer. Some parts might work with GCC 4.7 or older versions of clang.</p>
<p>You might have to set the C++ version using the compiler option</p>
<pre><code>-std=c++11</code></pre>
<h2 id="operating-systems"><span class="header-section-number">2.2</span> Operating Systems</h2>
<dl>
<dt>Linux</dt>
<dd><p>Osmium is developed on Linux and tested best on that system. Debian Jessie (testing) and current Ubuntu systems come with everything needed for Osmium. Debian wheezy (stable) and the Ubuntu LTS release 12.04 don't have compilers current enough. If you are stuck on these systems, use a backported compiler.</p>
</dd>
<dt>Mac OSX</dt>
<dd><p>Osmium also works well on Mac OSX with the exception of the parts that need the mremap system call that is not available on Mac OSX.</p>
</dd>
<dt>Windows</dt>
<dd><p>Most of Osmium should work on Windows, but nobody has been actually testing it.</p>
</dd>
</dl>
<h2 id="build-system"><span class="header-section-number">2.3</span> Build System</h2>
<p>The example programs in the example directory use a simple Makefile to help compiling them. Osmium is simple enough that it doesn't need a large build systems like automake or cmake to compile programs using it. This means that it works with whatever build system you are using in your programs.</p>
<h2 id="large-file-support"><span class="header-section-number">2.4</span> Large File Support</h2>
<p>When working with OSM data you often have very large files with several gigabytes. This can lead to problems on 32bit systems. Use the options</p>
<pre><code>-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64</code></pre>
<p>for the compiler to make sure that large files work.</p>
<h2 id="include-what-you-need"><span class="header-section-number">2.5</span> Include What You Need</h2>
<p>Libosmium is a header-only library. You include those parts you need and ignore the rest. The library makes sure internal dependencies are followed, of course. Whatever you don't include doesn't bloat your program and it doesn't need execution time. And, what's more important, you do not have dependencies on external libraries that are not really needed for whatever you are doing.</p>
<p>The full Osmium library has a frightening array of dependencies, but thats because its mission is to make OSM data usable with all those libraries. But if you don't need some part of Osmium, you also will not need those libraries.</p>
<p>You will find information about which files to include in the different chapters of this manual. Generally for a class <code>osmium::foo::Bar</code>, there will be an include file called <code>&lt;osmium/foo/bar.hpp&gt;</code> that you need to include, but sometimes it is a bit more difficult.</p>
<p>Do not directly include any header files in directories called &quot;detail&quot;. They are for internal use of the library only.</p>
<h2 id="boost"><span class="header-section-number">2.6</span> Boost</h2>
<p>Some parts of Osmium need some <a href="http://www.boost.org/">Boost</a> libraries. Libraries used are:</p>
<ul>
<li><a href="http://www.boost.org/libs/utility/operators.htm">Operators</a></li>
<li><a href="http://www.boost.org/libs/iterator/doc/">Iterator</a></li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/libs/algorithm/string/">String Algorithms</a></li>
</ul>
<p>Osmium also needs some Boost unicode functions. Because they are rather new and not available everywhere, they are currently included with Osmium in <code>include/boost_unicode_iterator.hpp</code>.</p>
<p>The Osmium unit tests use the <a href="http://www.boost.org/libs/test/">Boost Test library</a>.</p>
<h2 id="ogr-support"><span class="header-section-number">2.7</span> OGR Support</h2>
<p>Osmium can create OGR geometries from OSM data. To use this compile with what the command</p>
<pre><code>gdal-config --cflags</code></pre>
<p>returns and link with what</p>
<pre><code>gdal-config --libs</code></pre>
<p>returns.</p>
<h1 id="basic-types"><span class="header-section-number">3</span> Basic Types</h1>
<p>All the types and classes described in this chapter are value types, ie they are small and can be copied around cheaply.</p>
<h2 id="ids"><span class="header-section-number">3.1</span> IDs</h2>
<p>Typedef: <code>osmium::object_id_type</code></p>
<p>Include: <code>&lt;osmium/osm/types.hpp&gt;</code></p>
<p>For object IDs use the type <code>osmium::object_id_type</code>. It is a 64bit signed integer that can represent the more than 2 billion nodes we already have in OSM. While way and relation IDs could theoretically use a smaller ID type (signed 32 bit are currently enough), for consistency and to be future-proof, they will also use this type in most cases.</p>
<p>OSM objects always have positive IDs. But some software (such as JOSM) uses negative IDs for objects that have not yet been uploaded to the main OSM database. To support these use cases, the <code>object_id_type</code> is a signed integer.</p>
<p>Some parts of Osmium, notably the different index classes, can only work with positive IDs. In those cases the type <code>osmium::unsigned_object_id_type</code> is used. If you know that your data only contains positive IDs or only negative IDs, you can use the <code>positive_id()</code> member function on the <code>Object</code> class to get IDs of that type. It will return the absolute value of the ID.</p>
<p>If your data contains a mix of positive and negative IDs, this simple approach will fail! In that case you have to use two indexes, one for the positive IDs and one for the negative IDs. The <code>osmium::handler::NodeLocationsForWay</code> class takes this approach.</p>
<h2 id="other-primitive-types"><span class="header-section-number">3.2</span> Other Primitive Types</h2>
<p>Include: <code>&lt;osmium/osm/types.hpp&gt;</code></p>
<p>There are several other typedefs:</p>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>object_version_type</code></td>
<td align="left">type for OSM object version number</td>
</tr>
<tr class="even">
<td align="left"><code>changeset_id_type</code></td>
<td align="left">type for OSM changeset IDs</td>
</tr>
<tr class="odd">
<td align="left"><code>user_id_type</code></td>
<td align="left">type for OSM user IDs</td>
</tr>
<tr class="even">
<td align="left"><code>num_changes_type</code></td>
<td align="left">type for changeset num_changes</td>
</tr>
</tbody>
</table>
<p>All these types are currently 32bit integers. Version numbers, changeset IDs and User IDs are always positive (they start out with 1). The number of changes can be 0 or larger.</p>
<h2 id="locations"><span class="header-section-number">3.3</span> Locations</h2>
<p>Class: <code>osmium::Location</code></p>
<p>Include: <code>&lt;osmium/osm/location.hpp&gt;</code></p>
<p>In Osmium all positions on Earth are stored in objects of the osmium::Location class. Coordinates are stored as 32 bit signed integers after multiplying the coordinates with <code>osmium::coordinate_precision</code> = 10,000,000. This means we can store coordinates with a resolution of better than one centimeter, good enough for OSM use. The main OSM database uses the same system. We do this to save memory, a 32 bit integer uses only 4 bytes, a double uses 8.</p>
<p>Coordinates are not checked when they are set.</p>
<p>To create a location:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::Location location(<span class="fl">9.</span><span class="dv">3</span>, <span class="fl">49.</span><span class="dv">7</span>);</code></pre>
<p>or using integers:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::Location location(<span class="dv">9300000000</span>, <span class="dv">49700000000</span>);</code></pre>
<p>Make sure you are using the right number type or you will get very wrong coordinates.</p>
<p>You can also create an undefined location. This is used for instance for coordinates in ways that are not set yet:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::Location location();</code></pre>
<p>In a boolean context an undefined location returns false, a defined true. So you can write something like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (location) {
    ...defined location here...
}</code></pre>
<p>You can get and set the coordinates using the internal (integer) format with the <code>x()</code> and <code>y()</code> member functions and the external (double) format with the <code>lon()</code> and <code>lat()</code> member functions.</p>
<p>The normal bounds for the longitude and latitude are -180 to 180 and -90 to 90, respectively. But in historic OSM data you can sometimes find locations outside these bounds. Call</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">location.valid()</code></pre>
<p>to find out if a location is inside those bounds.</p>
<p>The <code>lon()</code> and <code>lat()</code> getter calls will throw an exception if the location is invalid or undefined.</p>
<h2 id="segments"><span class="header-section-number">3.4</span> Segments</h2>
<p>Class: <code>osmium::Segment</code></p>
<p>Include: <code>&lt;osmium/osm/segment.hpp&gt;</code></p>
<p>Segments are the directed connection between two locations. They are not OSM objects but sometimes useful in algorithms.</p>
<h2 id="undirected-segments"><span class="header-section-number">3.5</span> Undirected Segments</h2>
<p>Class: <code>osmium::UndirectedSegment</code></p>
<p>Include: <code>&lt;osmium/osm/undirected_segment.hpp&gt;</code></p>
<p>Undirected Segments are connection between two locations. They are not OSM objects but sometimes useful in algorithms.</p>
<h2 id="boxes"><span class="header-section-number">3.6</span> Boxes</h2>
<p>Class: <code>osmium::Box</code></p>
<p>Include: <code>&lt;osmium/osm/box.hpp&gt;</code></p>
<p>A box is a rectangle described by the minimum and maximum longitude and latitude. It is used, for instance, in the header of OSM files and in changesets to describe the bounding box.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::Box box;
box.extend(osmium::Location(<span class="fl">3.</span><span class="dv">2</span>, <span class="fl">4.</span><span class="dv">3</span>));
box.extend({<span class="fl">4.</span><span class="dv">5</span>, <span class="fl">7.</span><span class="dv">2</span>});
box.extend({<span class="fl">3.</span><span class="dv">3</span>, <span class="fl">8.</span><span class="dv">9</span>});
std::cout &lt;&lt; box;  <span class="co">// (3.2,4.3,4.5,8.9)</span></code></pre>
<h1 id="osm-entities"><span class="header-section-number">4</span> OSM Entities</h1>
<p>Osmium works with the four basic types of OSM entities: Nodes, Ways, and Relations (which are all <a href="#osm-objects">OSM Objects</a>) and Changesets. In addition Areas are supported, which are not native OSM objects, but they are almost treated like real OSM objects.</p>
<p>These OSM entities can not be created like any normal C++ object, but they need a buffer to live in. See the next chapter for details. Accessing existing OSM entities on the other hand is easy and straightforward.</p>
<h2 id="osm-objects"><span class="header-section-number">4.1</span> OSM Objects</h2>
<p>Class: <code>osmium::OSMObject</code></p>
<p>Include: <code>&lt;osmium/osm/object.hpp&gt;</code></p>
<p>The <code>osmium::OSMObject</code> class is the base class for nodes, ways, and relations. it has accessors for the usual OSM attributes:</p>
<pre><code>osmium::OSMObject&amp; obj = ...
std::cout &lt;&lt; &quot;id=&quot; &lt;&lt; obj.id()
          &lt;&lt; &quot; version=&quot; &lt;&lt; obj.version()
          &lt;&lt; &quot; timestamp=&quot; &lt;&lt; obj.timestamp()
          &lt;&lt; &quot; visible=&quot; &lt;&lt; (obj.visible() ? &quot;true&quot; : &quot;false&quot;
          &lt;&lt; &quot; changeset=&quot; &lt;&lt; obj.changeset()
          &lt;&lt; &quot; uid=&quot; &lt;&lt; obj.uid()
          &lt;&lt; &quot; user=&quot; &lt;&lt; obj.user() &lt;&lt; &quot;\n&quot;;</code></pre>
<p>The <code>changeset()</code> and <code>uid()</code> accessor functions return the IDs of the changeset that created this object version and the User ID of the user creating this version of the object, respectively. They do not link to an object of that type.</p>
<p>The <code>visible</code> flag will always be true for normal OSM data, but for history data or change files it shows whether an object version has been deleted.</p>
<p>In addition each object has a list of tags attached:</p>
<pre><code>const osmium::TagList&amp; tags = obj.tags();</code></pre>
<p>You can iterate over all tags:</p>
<pre><code>for (const osmium::Tag&amp; tag : obj.tags()) {
    std::cout &lt;&lt; tag.key() &lt;&lt; &quot;=&quot; &lt;&lt; tag.value() &lt;&lt; &quot;\n&quot;;
}</code></pre>
<p>Or you can find specific tags:</p>
<pre><code>const char* highway = obj.tags().get_value_by_key(&quot;highway&quot;);
if (highway &amp;&amp; !strcmp(highway, &quot;primary&quot;) {
    ...
}</code></pre>
<h2 id="nodes"><span class="header-section-number">4.2</span> Nodes</h2>
<p>Class: <code>osmium::Node</code></p>
<p>Include: <code>&lt;osmium/osm/node.hpp&gt;</code></p>
<p>A <code>Node</code> is a kind of <code>OSMObject</code>. In addition to the things you can do with any OSMObject, the Node has a Location.</p>
<pre><code>osmium::Node&amp; node = ...
double longitude = node.location().lon();</code></pre>
<h2 id="ways"><span class="header-section-number">4.3</span> Ways</h2>
<p>Classes: <code>osmium::Way</code>, <code>osmium::WayNode</code>, <code>osmium::WayNodeList</code></p>
<p>Include: <code>&lt;osmium/osm/way.hpp&gt;</code></p>
<p>A <code>Way</code> is a kind of <code>OSMObject</code>. In addition to the things you can do with any OSMObject, a Way has a list of node references:</p>
<pre><code>osmium::Way&amp; way = ...
for (const osmium::NodeRef&amp; nr : way.nodes()) {
    std::cout &lt;&lt; &quot;ref=&quot; &lt;&lt; nr.ref() &lt;&lt; &quot; location=&quot; &lt;&lt; nr.location() &lt;&lt; &quot;\n&quot;;
}</code></pre>
<h2 id="relations"><span class="header-section-number">4.4</span> Relations</h2>
<p>Classes: <code>osmium::Relation</code>, <code>osmium::RelationMember</code>, <code>osmium::RelationMemberList</code></p>
<p>Include: <code>&lt;osmium/osm/relation.hpp&gt;</code></p>
<p>A <code>Relation</code> is a kind of <code>OSMObject</code>. In addition to the things you can do with any OSMObject, a Relation has a list of members:</p>
<pre><code>osmium::Relation&amp; relation = ...
osmium::RelationMemberList&amp; rml = way.members();
for (osmium::RelationMember&amp; rm : rml) {
    std::cout &lt;&lt; rm.type() &lt;&lt; rm.ref() &lt;&lt; &quot; (role=&quot; &lt;&lt; rm.role() &lt;&lt; &quot;)\n&quot;;
}</code></pre>
<h2 id="areas"><span class="header-section-number">4.5</span> Areas</h2>
<p><em>not yet documented</em></p>
<h2 id="changesets"><span class="header-section-number">4.6</span> Changesets</h2>
<p>Class: <code>osmium:Changeset</code></p>
<p>Include: <code>&lt;osmium/osm/changeset.hpp&gt;</code></p>
<p>Changesets contain the metadata for a set of changes to OSM data.</p>
<pre><code>osmium::Changeset</code></pre>
<h1 id="buffers"><span class="header-section-number">5</span> Buffers</h1>
<p>OSM entities have to be stored somewhere in memory. They are complex objects containing arbitrary number of tags, relations can have any number of members etc. If we handled those objects like any normal C++ object, creating them would take lots of small memory allocations and many pointer indirections to get at all the parts of the data. Instead OSM entities are created inside so-called <em>buffers</em>. Buffers can have a fixed size or grow as needed. New objects can be added at the end, and they are stored inside those buffers in a reasonably space-efficient manner while still being accessible easily and quickly.</p>
<p>Buffers can be moved around between different parts of your program and even between threads. The content of buffers can even be written to disk as it is and read back in and immediately used &quot;as is&quot; without any serializaton or de-serialization step needed.</p>
<p>But all of this has one draw-back: It is slightly more complicated to create those objects and they can not just be instantiated on the stack.</p>
<p>Buffers can not be copied, because it is unclear who would be responsible for the memory then. But they can be moved.</p>
<h2 id="creating-a-buffer"><span class="header-section-number">5.1</span> Creating a Buffer</h2>
<p>Buffers exist in two different flavours, those with external memory management and those with internal memory management. If you already have some memory with data in it (for instance read from disk), you create a Buffer with external memory managment. It is your job then to free the memory once the buffer isn't used any more. If you don't have some memory space already, you can create a Buffer object and have it manage the memory internally. It will dynamically allocate memory and free it again after use.</p>
<p>To create a buffer from existing memory you give the address and size to the constructor:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> buffer_size = <span class="dv">10240</span>;
<span class="dt">void</span>* mem = malloc(buffer_size);
osmium::memory::Buffer buffer(mem, buffer_size);</code></pre>
<p>This will create an empty buffer with <code>buffer_size</code> bytes available for use.</p>
<p>If the new buffer already contains some data, you can add the number of bytes already in use as a third parameter to the constructor:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>* mem = malloc(buffer_size);
<span class="dt">int</span> num = read(<span class="dv">0</span>, mem, buffer_size);
osmium::memory::Buffer buffer(mem, buffer_size, num);</code></pre>
<p>To create a buffer with internal memory-management you construct it with the number of bytes it should have initially and a flag that tells Osmium whether it should automatically grow the buffer if it is needed:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> buffer_size = <span class="dv">10240</span>;
osmium::memory::Buffer buffer(buffer_size, osmium::memory::Buffer::auto_grow::yes);
osmium::memory::Buffer buffer(buffer_size, osmium::memory::Buffer::auto_grow::no);</code></pre>
<h2 id="adding-items-to-the-buffer"><span class="header-section-number">5.2</span> Adding Items to the Buffer</h2>
<h2 id="handling-a-full-buffer"><span class="header-section-number">5.3</span> Handling a Full Buffer</h2>
<p>If a buffer becomes full, there are three different things that can happen:</p>
<p>If the buffer was created with <code>auto_grow::yes</code>, it will reserve more memory on the heap and double its size. This will happen without the client code noticing, but it will invalidate any pointer pointing into the buffer. This is the same behaviour a <code>std::vector</code> has so it should be familiar to C++ programmers.</p>
<p>If the buffer was created with <code>auto_grow::no</code> (or if it is a buffer with external memory management), the exception <code>osmium::memory::BufferIsFull</code> will be thrown. In this case you have to catch the exception, either grow the buffer or create a new one. If you grow the buffer you can keep going at the point where you left off. If you start a new one, the last object you were writing to the buffer when the exception was thrown was not committed and you have to write it again into the new buffer.</p>
<p>As a third option you can set a <em>callback</em> functor that wil be called when the buffer is full. The functor takes a reference to the buffer as argument and returns void:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> full(osmium::memory::Buffer&amp; buffer) {
    std::cout &lt;&lt; <span class="st">&quot;Buffer is full</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

osmium::memory::Buffer buffer(buffer_size, <span class="kw">false</span>);
buffer.set_full_callback(full);</code></pre>
<h1 id="input-and-output"><span class="header-section-number">6</span> Input and Output</h1>
<p>Most programs using OSM data will need to read from OSM files and/or write to OSM files. Osmium supports several different OSM file formats and has many different ways of accessing the data in convenient ways.</p>
<h2 id="file-formats"><span class="header-section-number">6.1</span> File Formats</h2>
<p>Osmium supports the following formats:</p>
<dl>
<dt><strong>XML</strong></dt>
<dd><p>The original XML-based OSM format. This format is rather verbose and working with it is slow, but it is still used often and in some cases there is no alternative. The main OSM database API also returns its data in this format. More information about this format on the <a href="http://wiki.openstreetmap.org/wiki/OSM_XML">OSM Wiki</a>.</p>
</dd>
<dt><strong>PBF</strong></dt>
<dd><p>The binary format based on the Protobuf library. This is the most compact format. More information on the <a href="http://wiki.openstreetmap.org/wiki/PBF_Format">OSM Wiki</a>.</p>
</dd>
<dt><strong>OPL</strong></dt>
<dd><p>A simple format similar to CSV-files with one OSM entity per line. This format is intended for easy use with standard UNIX command line tools such as <code>grep</code>, <code>cut</code>, and <code>awk</code>.</p>
</dd>
</dl>
<p>See <a href="#output-formats">Output Formats</a> for more details about these formats.</p>
<h2 id="compression"><span class="header-section-number">6.2</span> Compression</h2>
<p>Osmium supports compression and decompression of XML and OPL files internally using the GZIP and BZIP2 formats. If you want to use compression you have to include the right header files and link to the <code>libz</code> and <code>libbz2</code> libraries, respectively.</p>
<h2 id="headers"><span class="header-section-number">6.3</span> Headers</h2>
<p>Whenever you want to use Osmium to access OSM files you need to include the right header files and link your program to the right libraries. If you want to support all the different formats you add</p>
<pre><code>#include &lt;osmium/io/any_input.hpp&gt;</code></pre>
<p>and/or</p>
<pre><code>#include &lt;osmium/io/any_output.hpp&gt;</code></pre>
<p>to your C++ files. These headers will pull in all the file formats and all the compression types for input and output, respectively. Usually this is what you want to use. But if you are sure you don't need all formats or if you don't have all the libraries needed for all the formats, you can pick and choose formats and compression types.</p>
<p>If you only need some file formats, you can include any combinations of the following headers:</p>
<pre><code>#include &lt;osmium/io/pbf_input.hpp&gt;
#include &lt;osmium/io/xml_input.hpp&gt;

#include &lt;osmium/io/pbf_output.hpp&gt;
#include &lt;osmium/io/opl_output.hpp&gt;
#include &lt;osmium/io/xml_output.hpp&gt;</code></pre>
<p>If you want compression support, you have to add the includes for the different compression algorithms:</p>
<pre><code>#include &lt;osmium/io/gzip_compression.hpp&gt;
#include &lt;osmium/io/bzip2_compression.hpp&gt;</code></pre>
<p>Or, if you want both anyway, you can just use the shortcut:</p>
<pre><code>#include &lt;osmium/io/any_compression.hpp&gt;</code></pre>
<h2 id="output-formats"><span class="header-section-number">6.4</span> Output Formats</h2>
<h3 id="xml"><span class="header-section-number">6.4.1</span> XML</h3>
<p>There are several different XML formats in use in the OSM project. The main formats are the one used for planet files, extracts, and API responses (suffix <code>.osm</code>), the format used for change files (suffix <code>.osc</code>) and the history format (suffixes <code>.osm</code> or <code>.osh</code>).</p>
<p>Some variants are also used, such as the JOSM format which is similiar to the normal OSM format but has some additions. Support for the features of these formats varies.</p>
<p>When reading, the OSM change format (<code>.osc</code>) is detected automatically. When writing, you have to set it using the format specifier <code>osc</code> or the format parameter <code>xml_change_format=true</code>.</p>
<p>For read support you need the expat parser library. Link with:</p>
<pre><code>-lexpat</code></pre>
<p>For write support no special library is needed.</p>
<h3 id="pbf"><span class="header-section-number">6.4.2</span> PBF</h3>
<p>The <a href="http://wiki.openstreetmap.org/wiki/PBF_Format">PBF</a> file format is based on the <a href="http://code.google.com/p/protobuf/">Google Protocol Buffers library</a>. PBF files are very space efficient and faster to use than XML files. PBF files can contain normal OSM data or OSM history data, but there is no equivalent to the XML .osc format.</p>
<p>The OSM PBF format is defined in <a href="https://github.com/scrosby/OSM-binary">libosmpbf</a>, you'll probably have to compile and install this yourself before using it in Osmium.</p>
<p>To build with PBF support, several libraries are needed: libprotobuf-lite contains the Protocol Buffers library itself which also needs libpthreads, for compression libz is needed. Those are all standard libraries that should be available on most systems.</p>
<p>To summarize, you need to link with:</p>
<pre><code>-pthread -lprotobuf-lite -losmpbf -lz</code></pre>
<p>The Google Protocol Buffers library allocates some global buffer memory which is never freed. You can call the following function in your code to free these buffers:</p>
<pre><code>google::protobuf::ShutdownProtobufLibrary();</code></pre>
<p>You do not have to do this, the function is not necessary for the correct functioning of your program. But if you are using a memory checker like Valgrind you will get error messages otherwise.</p>
<p>Osmium supports reading and writing of nodes in <em>DenseNodes</em> and non-<em>DenseNodes</em> formats. Default is <em>DenseNodes</em>, as this is much more space-efficient. Add the format parameter <code>pbf_dense_nodes=false</code> to disable <em>DenseNodes</em>.</p>
<p>Osmium usually will compress PBF blocks using zlib. To disable this, use the format parameter <code>pbf_compression=none</code>.</p>
<p>Usually PBF files contain all the metadata for objects such as changeset id, username, etc. To save some space you can disable writing of metatdata with the format parameter <code>pbf_add_metadata=false</code>.</p>
<h3 id="opl-object-per-line-format"><span class="header-section-number">6.4.3</span> OPL (&quot;Object Per Line&quot;) Format</h3>
<p><em>This format is preliminary, it might change. Please send feedback if you use this format!</em></p>
<p>This format was created to allow easy access to and manipulation of OSM data with typical UNIX command line tools such as <code>grep</code>, <code>sed</code>, and <code>awk</code>. This can make some ad-hoc OSM data manipulation easy to do, but is probably not as fast as some specialized tool. But it beats grepping in XML files...</p>
<p>OPL files are only about half the size of OSM XML files, but when compressed they are about the same size.</p>
<p>Osmium currently can write OPL files, but not read them.</p>
<p>Each line of the file contains one OSM object (a node, way, or relation) or an OSM changeset. Fields are separated by a space character, lines by a newline character. Fields always appear in the same order and are always present, each field is introduced by a specific character:</p>
<p>One of these fields is always the first:</p>
<pre><code>n - Node ID (nodes only)
w - Way ID (ways only)
r - Relation ID (relations only)
c - Changeset ID (changesets only)</code></pre>
<p>Then for OSM objects in the given order:</p>
<pre><code>v - Version
d - Deleted flag (&#39;V&#39; - visible or &#39;D&#39; - deleted)
c - Changeset ID
t - Timestamp (ISO Format)
i - User ID
u - Username
T - Tags
x - Longitude (nodes only)
y - Latitude (nodes only)
N - Nodes (ways only)
M - Members (relations only)</code></pre>
<p>The N, M, and T fields can be empty. If the user is anonymous, the 'User ID' will be 0 and the 'Username' field will be empty: <code>... i0 u ...</code>. If the node is deleted, the 'Longitude' and 'Latitude' fields are empty. All other fields always contain data.</p>
<p>The 'Deleted flag' shows whether an object version has been deleted (<code>dD</code>) or whether it is visible (<code>dV</code>). For normal OSM data files this is always <code>dV</code>, but change files and osm history files can contain deleted objects.</p>
<p>For changesets the fields are different:</p>
<pre><code>k - num_changes
s - created_at (start) timestamp (ISO Format)
e - closed_at (end) timestamp (ISO Format)
i - User ID
u - Username
x - Longitude (left bottom corner, min_lon)
y - Latitude (left bottom corner, min_lat)
X - Longitude (right top corner, max_lon)
Y - Latitude (right top corner, max_lat)
T - Tags</code></pre>
<p>The fields e is empty when the changeset is not closed yet. The fields x, y, X, Y can be empty when no bounding box could be derived. The field k can be 0.</p>
<p><strong>Escaping</strong></p>
<p>User names, tags, and relation member roles can contain any valid Unicode character. Any characters that have special meaning in OPL files (' ' (space), ',' (comma), '=' (equals) and '@') have to be escaped as well as any non-printing characters.</p>
<p>Escaped characters are written as <code>%xxxx</code>, ie a percent sign followed by the 4-digit hex code of the Unicode code point.</p>
<p>Currently there is a hard-coded list in the code of all the characters that don't need escaping. This list is incomplete and subject to change.</p>
<p><strong>Format Overview</strong></p>
<p>(Some lines have been broken in this description for easier reading, in the file format they are not.)</p>
<pre><code>NODE:
    n(OBJECT_ID) v(VERSION) d(V|D) c(CHANGESET_ID) t(yyyy-mm-ddThh:mm:ssZ)
    i(USER_ID) u(USERNAME) T(TAGS) x(LONGITUDE) y(LATITUDE)

WAY:
    w(OBJECT_ID) v(VERSION) d(V|D) c(CHANGESET_ID) t(yyyy-mm-ddThh:mm:ssZ)
    i(USER_ID) u(USERNAME) T(TAGS) N(WAY_NODES)

RELATION:
    r(OBJECT_ID) v(VERSION) d(V|D) c(CHANGESET_ID) t(yyyy-mm-ddThh:mm:ssZ)
    i(USER_ID) u(USERNAME) T(TAGS) M(MEMBERS)

CHANGESET:
    c(CHANGESET_ID) k(NUM_CHANGES) s(yyyy-mm-ddThh:mm:ssZ) e(yyyy-mm-ddThh:mm:ssZ)
    i(USER_ID) u(USERNAME) x(LONGITUDE) y(LATITUDE) X(LONGITUDE) Y(LATITUDE) T(TAGS)

TAGS
    (KEY)=(VALUE),...

WAY_NODES:
    n(NODE_REF),...

MEMBERS:
    [nwr](MEMBER_REF)@(MEMBER_ROLE),...</code></pre>
<p><strong>Usage Examples</strong></p>
<p>(Note that some of these commands generate quite a lot of output. You might want to add a <code>| less</code> or redirect into a file. For larger OSM files some of these commands might take quite a while, so try them out on small files first.)</p>
<p>Find all objects tagged <code>highway=...</code>:</p>
<pre><code>egrep &quot;( T|,)highway=&quot; data.osm.opl</code></pre>
<p>Find all IDs of ways tagged <code>highway=...</code>:</p>
<pre><code>egrep &#39;^w&#39; data.osm.opl | egrep &quot;( T|,)highway=&quot; | cut -d&#39; &#39; -f1 | cut -c2-</code></pre>
<p>Find all nodes with version &gt; 9:</p>
<pre><code>egrep &#39;^n&#39; data.osm.opl | egrep -v &#39; v. &#39;</code></pre>
<p>Find the first fields of the relation with the highest version number:</p>
<pre><code>egrep &#39;^r&#39; data.osm.opl | sort -b -n -k 2.2,2 | tail -1 | cut -d&#39; &#39; -f1-7</code></pre>
<p>Find all objects with changeset ID 123:</p>
<pre><code>egrep &#39; c123 &#39; data.osm.opl</code></pre>
<p>Count how many objects were created in each hour of the day:</p>
<pre><code>egrep &#39; v1 &#39; data.osm.opl | cut -d&#39; &#39; -f5 | cut -dT -f2 | cut -d: -f1 | sort | uniq -c</code></pre>
<p>Find all closed ways:</p>
<pre><code>egrep &#39;^w&#39; data.osm.opl | egrep &#39;N(n[0-9]+),.*\1 &#39;</code></pre>
<p>Find all ways tagged with <code>area=yes</code> that are not closed:</p>
<pre><code>egrep &#39;^w&#39; data.osm.opl | egrep &#39;area=yes&#39; | egrep -v &#39;N(n[0-9]+),.*\1 &#39;</code></pre>
<p>Find all users who have created post boxes:</p>
<pre><code>egrep &#39; v1 &#39; data.osm.opl | egrep &#39;amenity=post_box&#39; | cut -d&#39; &#39; -f7 | cut -c2- | sort -u</code></pre>
<p>Find all node IDs used in <code>via</code> roles in relations:</p>
<pre><code>egrep &#39;^r&#39; data.osm.opl | sed -e &#39;s/^.* M\(.*\) .*$/\1/&#39; | egrep &#39;@via[, ]&#39; | \
    sed -e &#39;s/,/\n/g&#39; | egrep &#39;^n.*@via$&#39; | cut -d@ -f1 | cut -c2- | sort -nu</code></pre>
<p>Find all nodes having any tags igoring <code>created_by</code> tags:</p>
<pre><code>egrep &#39;^n&#39; data.osm.opl | egrep -v &#39; T$&#39; | sed -e &#39;s/\( T\|,\)created_by=[^,]\+\(,\|$\)/\1/&#39; | egrep -v &#39; T$&#39;</code></pre>
<p>Count tag key usage:</p>
<pre><code>sed -e &#39;s/^.* T//&#39; data.osm.opl | egrep -v &#39;^$&#39; | sed -e &#39;s/,/\n/g&#39; | cut -d= -f1 | sort | uniq -c | sort -nr</code></pre>
<p>Order by object type, object id and version (ie the usual order for OSM files):</p>
<pre><code>sed -e &#39;s/^r/z/&#39; data.osm.opl | sort -b -k1.1,1.1 -k1.2,1n -k2.2,2n | sed -e &#39;s/^z/r/&#39;</code></pre>
<p>Create statistics on number of nodes in ways:</p>
<pre><code>egrep &#39;^w&#39; data.osm.opl | cut -d&#39; &#39; -f9 | tr -dc &#39;n\n&#39; | \
    awk &#39;{a[length]++} END {for(i=1;i&lt;=2000;++i) { print i, a[i] ? a[i] : 0 } }&#39;</code></pre>
<h2 id="reading-and-writing-osm-files-with-osmium"><span class="header-section-number">6.5</span> Reading and Writing OSM Files with Osmium</h2>
<h3 id="the-osmiumiofile-class"><span class="header-section-number">6.5.1</span> The osmium::io::File class</h3>
<p>Before reading from or writing to an OSM file, you have to instantiate an object of class osmium::io::File. It encapsulates the file name as well as any information about the format of the file. In the simplest case the File class can derive the file format from the file name:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File input_file(<span class="st">&quot;planet.osm.pbf&quot;</span>) <span class="co">// PBF format</span>
osmium::io::File input_file(<span class="st">&quot;planet.osm.bz2&quot;</span>) <span class="co">// XML with bzip2 compression</span>
osmium::io::File input_file(<span class="st">&quot;planet.osc.gz&quot;</span>)  <span class="co">// XML change file, gzip2 compression</span></code></pre>
<p>The constructor of the File class has a second, optional argument giving the format of the file, which can be used if the format can't be deduced from the file name. In the simplest form the format argument looks the same as the usual file suffixes:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File input_file(<span class="st">&quot;somefile&quot;</span>, <span class="st">&quot;osm.bz2&quot;</span>);</code></pre>
<p>This setting of the format is often needed when reading from STDIN or writing to STDOUT. Both an empty string and a single dash as filename signify STDIN/STDOUT:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File input_file(<span class="st">&quot;-&quot;</span>, <span class="st">&quot;osm.bz2&quot;</span>);
osmium::io::File output_file(<span class="st">&quot;&quot;</span>, <span class="st">&quot;pbf&quot;</span>);</code></pre>
<p>The format string can also take optional arguments separated by commas.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File output_file(<span class="st">&quot;out.osm.pbf&quot;</span>, <span class="st">&quot;pbf,pbf_dense_nodes=false&quot;</span>);</code></pre>
<p>Here is a list of optional arguments:</p>
<table>
<thead>
<tr class="header">
<th align="left">Format</th>
<th align="left">Option</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">PBF</td>
<td align="left">pbf_dense_nodes</td>
<td align="left">true</td>
<td align="left">Use DenseNodes (more space efficient)</td>
</tr>
<tr class="even">
<td align="left">PBF</td>
<td align="left">pbf_compression</td>
<td align="left">gzip</td>
<td align="left">Compress blocks using gzip (use &quot;none&quot; to disable)</td>
</tr>
<tr class="odd">
<td align="left">PBF</td>
<td align="left">pbf_add_metadata</td>
<td align="left">true</td>
<td align="left">Add metadata (version, timestamp, etc. to objects)</td>
</tr>
<tr class="even">
<td align="left">XML</td>
<td align="left">xml_change_format</td>
<td align="left">false</td>
<td align="left">Set change format, can also be set by using <code>osc</code> instead of <code>osm</code> suffix</td>
</tr>
<tr class="odd">
<td align="left">XML</td>
<td align="left">force_visible_flag</td>
<td align="left">false</td>
<td align="left">Write out <code>visible</code> flag on each object, also set if <code>osh</code> instead of <code>osm</code> suffix used</td>
</tr>
</tbody>
</table>
<p>It is also possible to change the format after creating a File object using the accessor functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File input_file(<span class="st">&quot;some_file.osm&quot;</span>);
input_file.format(osmium::io::file_format_pbf);</code></pre>
<h3 id="reading-a-file"><span class="header-section-number">6.5.2</span> Reading a File</h3>
<p>After you have a File object you can instantiate a Reader object to open the file for reading:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::File input_file(<span class="st">&quot;input.osm.pbf&quot;</span>);
osmium::io::Reader reader(input_file);</code></pre>
<p>As a shortcut you can just give a file name to the Reader if you are relying on the automatic file format detection and don't want to do any special format handling:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::Reader reader(<span class="st">&quot;input.osm.pbf&quot;</span>);</code></pre>
<p>Optionally you can add a second argument to the Reader constructor giving the types of OSM entities you are interested in. Sometimes you only need, say, the ways from the file, but not the nodes and relations. If you tell the Reader about it, it might be able to read the file more efficiently by skipping those parts you are not interested in:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::Reader reader(<span class="st">&quot;input.osm.pbf&quot;</span>, osmium::osm_entity_bits::way);</code></pre>
<p>You can set the following flags:</p>
<table>
<thead>
<tr class="header">
<th align="left">Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>osmium::osm_entity_bits::nothing</code></td>
<td align="left">Do not ready any entities at all (useful if you are only interested in the file header)</td>
</tr>
<tr class="even">
<td align="left"><code>osmium::osm_entity_bits::node</code></td>
<td align="left">Read nodes</td>
</tr>
<tr class="odd">
<td align="left"><code>osmium::osm_entity_bits::way</code></td>
<td align="left">Read ways</td>
</tr>
<tr class="even">
<td align="left"><code>osmium::osm_entity_bits::relation</code></td>
<td align="left">Read relations</td>
</tr>
<tr class="odd">
<td align="left"><code>osmium::osm_entity_bits::changeset</code></td>
<td align="left">Read changesets</td>
</tr>
<tr class="even">
<td align="left"><code>osmium::osm_entity_bits::all</code></td>
<td align="left">Read all of the above</td>
</tr>
</tbody>
</table>
<p>You can also &quot;or&quot; several flags together if needed.</p>
<p>You can get the header information from the file using the <code>header()</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::Header header = reader.header();</code></pre>
<p>You read the OSM entities from the file using the <code>read()</code> which returns a buffer with the data:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> (osmium::memory::Buffer buffer = reader.read()) {
    ...
}</code></pre>
<p>At the end of the file an invalid buffer is returned which evaluates to false in boolean context.</p>
<p>You can close the file at any time. It will also be automatically closed when the Reader object goes out of scope.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">reader.close();</code></pre>
<p>In most cases you do not want to work with the buffers, but with the OSM entities within them. See the <a href="#iterators">Iterators</a> chapter and the <a href="#visitors-and-handlers">Visitors and Handlers</a> chapter for more convenient methods of working with open files.</p>
<h3 id="the-header"><span class="header-section-number">6.5.3</span> The Header</h3>
<table>
<thead>
<tr class="header">
<th align="left">Format</th>
<th align="left">Option</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">all</td>
<td align="left">generator</td>
<td align="left">Osmium/VERSION</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">XML</td>
<td align="left">xml_josm_upload</td>
<td align="left">not set</td>
<td align="left">Set <code>upload</code> attribute in header to given value (<code>true</code> or <code>false</code>) for use in JOSM</td>
</tr>
</tbody>
</table>
<h1 id="iterators"><span class="header-section-number">7</span> Iterators</h1>
<p>Every C++ programmer is familiar with iterators and their flexibility. There is no reason we couldn't take advantage of that and of the many algorithms supplied by the STL. So libosmium supports several different kinds of iterators to access OSM data. You can iterate over all OSM objects in a buffer, or over all objects from a data source (usually a file), or over a bunch of pointers to OSM objects, and there are output iterators to write to files, too. All these different iterators can be used consistently and easily from your code without having to know much about what's underneath. And because they work just like STL iterators do, you can use all the algorithms from the STL.</p>
<p>Some of these iterators will keep track of underlying buffers and make sure the buffers and the data in them stay around as long as there is an iterator pointing to it. This adds some overhead but makes using the data much easier.</p>
<h2 id="accessing-data-in-buffers"><span class="header-section-number">7.1</span> Accessing Data in Buffers</h2>
<p>Buffers containing OSM entities support the usual <code>begin()</code>, <code>end()</code>, <code>cbegin()</code>, and <code>cend()</code> functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::memory::Buffer buffer = ...;

<span class="kw">auto</span> it = buffer.begin();
<span class="kw">auto</span> end = buffer.end();

<span class="kw">for</span> (; it != end; ++it) {
    std::cout &lt;&lt; it-&gt;type() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}</code></pre>
<p>Of course you can also use the C++11 <code>for</code> loop:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="kw">auto</span>&amp; item : buffer) {
    ...
}</code></pre>
<h2 id="accessing-data-from-files"><span class="header-section-number">7.2</span> Accessing Data from Files</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">osmium::io::Reader reader(<span class="st">&quot;input.osm&quot;</span>);
osmium::io::InputIterator&lt;osmium::io::Reader&gt; in(reader);
osmium::io::InputIterator&lt;osmium::io::Reader&gt; end;</code></pre>
<h1 id="visitors-and-handlers"><span class="header-section-number">8</span> Visitors and Handlers</h1>
<h1 id="indexes"><span class="header-section-number">9</span> Indexes</h1>
<p>Osmium is built around the idea that a lot of the things you want to do with OSM data can be done one OSM object at the time without having all (or large parts of) the OSM data in memory or in some kind of database. But there are many things you can not do this way. You do need some kind of storage to hold the data and some indexes to access it efficiently. Osmium provides several class templates that implement several different types of indexes.</p>
<h2 id="index-types"><span class="header-section-number">9.1</span> Index Types</h2>
<p>Osmium provides indexes modelled after the STL map and multimap classes, respectively. These classes are to be found in the osmium::index::map and osmium::index::multimap namespaces.</p>
<h3 id="map-index"><span class="header-section-number">9.1.1</span> Map Index</h3>
<p>Often we need some small, fixed amount of data stored for each OSM object. Read and write access is by ID only. Typical use cases include...</p>
<ul>
<li>storage of node locations where for each node ID we store the longitude and latitude of that node.</li>
<li>storing the offset of an OSM object in a buffer.</li>
<li>a lookup table that gives you for each node ID all IDs of the way (or ways) that include this node.</li>
</ul>
<h3 id="storage-types"><span class="header-section-number">9.1.2</span> Storage types</h3>
<p>There are different strategies of storing this data efficiently and there are several sub-classes of the Map and Multimap classes that use different strategies. It is important that you understand the differences and use the class thats most appropriate for your case.</p>
<p>The differences can be understood along different axes:</p>
<p>First, the question is whether the ID space is dense or not. If you are using the full planet data or large portions (such as entire continents) thereof, your ID space is dense, ie most of the possible IDs are actually present in the index. If you are only using small extracts (even with whole countries in them), you ID space is sparse, ie most of the possible IDs are not present in the index. For dense indexes data is often best stored in a kind of array indexed by the ID. For sparse indexes there are several other possibilities.</p>
<p>The second question is whether you have enought RAM to hold all the data in the index. Of course it is more efficient to keep the index in RAM, but if you don't have enough you need to use a disk-based index.</p>
<pre><code>handler-example.cpp
    </code></pre>
<h4 id="list-of-map-index-classes"><span class="header-section-number">9.1.2.1</span> List of map index classes</h4>
<p>see also: table in spreadsheet dummy based on vector: with stl vector, with mmap_anon, with mmap_file other: stl map, google sparsetable</p>
<h4 id="list-of-multimap-index-classes"><span class="header-section-number">9.1.2.2</span> List of multimap index classes</h4>
<p>based on vector: with stl vector, with mmap_anon, with mmap_file other: stl multimap, hybrid</p>
<h1 id="exceptions"><span class="header-section-number">10</span> Exceptions</h1>
<p>Libosmium uses various C++ standard exceptions and some Osmium-specific exceptions to tell you about problems. All Osmium-specific exceptions are in the <code>osmium</code> namespace, they are all derived from one of the standard C++ exceptions, usually <code>std::runtime_error</code> or <code>std::system_error</code>.</p>
<h2 id="list-of-osmium-exceptions"><span class="header-section-number">10.1</span> List of Osmium Exceptions</h2>
<dl>
<dt><code>osmium::io_error</code></dt>
<dd><p>Some kind of input/output error. Derived classes describe the error in more detail.</p>
</dd>
<dt><code>osmium::xml_error</code> (derived from <code>io_error</code>)</dt>
<dd><p>Some kind of XML parser error.</p>
</dd>
<dt><code>osmium::format_version_error</code> (derived from <code>io_error</code>)</dt>
<dd><p>The OSM file format version was not understood. Osmium currently can only read version 0.6 files.</p>
</dd>
<dt><code>osmium::geometry_error</code></dt>
<dd><p>Some kind of geometry error.</p>
</dd>
<dt><code>osmium::projection_error</code></dt>
<dd><p>Thrown when a projection from one coordinate system into another fails in some way. Either the projection can't be initialized because of invalid parameters or the projection can't be calculated because the coordinates can't be transformed into the target coordinate system.</p>
</dd>
<dt><code>osmium::not_found</code></dt>
<dd><p>This exception is thrown when a key is not found in an index.</p>
</dd>
</dl>
<p><code>osmium::invalid_location</code></p>
<dl>
<dt><code>osmium::unknown_type</code></dt>
<dd>Thrown by visitors when they encounter an unknown (or in this context unexpected) item type in a buffer. This should not happen in usual circumstances.
</dd>
</dl>
<h2 id="standard-exceptions-thrown-by-osmium"><span class="header-section-number">10.2</span> Standard Exceptions thrown by Osmium</h2>
<dl>
<dt><code>std::invalid_argument</code></dt>
<dd>Thrown by some Osmium functions.
</dd>
</dl>
</body>
</html>
